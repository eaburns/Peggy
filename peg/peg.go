// Copyright 2017 The Peggy Authors
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd.

// Package peg contains common types and utilities for parsers generated by Peggy.
package peg

import (
	"bytes"
	"io"
	"strconv"
	"unicode/utf8"
)

// A Node is a node in a Peggy parse tree.
type Node struct {
	// Name is the name of the Rule associated with the node,
	// or the empty string for anonymous Nodes
	// that are not associated with any Rule.
	Name string

	// Text is the input text of the Node's subtree.
	Text string

	// Kids are the immediate successors of this node.
	Kids []*Node
}

func (f *Node) name() string         { return f.Name }
func (f *Node) numKids() int         { return len(f.Kids) }
func (f *Node) kid(i int) nodeOrFail { return f.Kids[i] }
func (f *Node) text() string         { return f.Text }

// A Fail is a node in a failed-parse tree.
// A failed-parse tree contains all paths in a failed parse
// that lead to the furthest error location in the input text.
// There are two types of nodes: named and unnamed.
// Named nodes represent grammar rules that failed to parse.
// Unnamed nodes represent terminal expressions that failed to parse.
type Fail struct {
	// Name is the name of the Rule associated with the node,
	// or the empty string if the Fail is a terminal expression failure.
	Name string

	// Pos is the byte offset into the input of the Fail.
	Pos int

	// Kids are the immediate succors of this Fail.
	// Kids is only non-nil for named Fail nodes.
	Kids []*Fail

	// Want is a string describing what was expected at the error position.
	// It is only non-empty for unnamed Fail nodes.
	//
	// It can be of one of the following forms:
	// 	"…" indicating a failed literal match, where the text between the quotes is the expected literal using Go escaping.
	// 	. indicating a failed . match.
	// 	[…] indicating a failed character class match, where the text between the [ and ] is the character class.
	// 	!… where the text after ! is the string representation of a failed predicate subexpression.
	// 	&… where the text after & is the string representation of a failed predicate subexpression.
	// 	… the error-name of a rule.
	// 		For example, "int" in rule: Integer "int" <- [0-9].
	Want string
}

func (f *Fail) name() string         { return f.Name }
func (f *Fail) numKids() int         { return len(f.Kids) }
func (f *Fail) kid(i int) nodeOrFail { return f.Kids[i] }
func (f *Fail) text() string         { return f.Want }

// DedupFails removes duplicate fail branches from the tree,
// keeping only the first occurrence of each.
// This is useful for example before printing the Fail tree,
// because the non-deduped Fail tree can be exponential
// in the input size.
func DedupFails(node *Fail) {
	seen := make(map[*Fail]bool)
	var walk func(*Fail) bool
	walk = func(n *Fail) bool {
		if seen[n] {
			return false
		}
		seen[n] = true
		var kids []*Fail
		for _, k := range n.Kids {
			if walk(k) {
				kids = append(kids, k)
			}
		}
		n.Kids = kids
		return true
	}
	walk(node)
}

type nodeOrFail interface {
	name() string
	numKids() int
	kid(int) nodeOrFail
	text() string
}

// Pretty returns a human-readable string of a Node or Fail
// and the subtree beneath it.
// The output looks like:
// 	<n.Name>{
// 		<Pretty(n.Kids)[0])>,
// 		<Pretty(n.Kids[1])>,
// 		…
// 		<Pretty(n.Kids[n-1])>,
// 	}
func Pretty(n nodeOrFail) string {
	b := bytes.NewBuffer(nil)
	PrettyWrite(b, n)
	return b.String()
}

// PrettyWrite is like Pretty but outputs to an io.Writer.
func PrettyWrite(w io.Writer, n nodeOrFail) error {
	return prettyWrite(w, "", n)
}

func prettyWrite(w io.Writer, tab string, n nodeOrFail) error {
	if _, err := io.WriteString(w, tab); err != nil {
		return err
	}
	_, fail := n.(*Fail)
	if n.numKids() == 0 && (n.name() == "" || fail && n.text() != "") {
		if _, err := io.WriteString(w, `"`+n.text()+`"`); err != nil {
			return err
		}
		return nil
	}
	if _, err := io.WriteString(w, n.name()); err != nil {
		return err
	}
	if f, ok := n.(*Fail); ok {
		pos := "[" + strconv.Itoa(f.Pos) + "]"
		if _, err := io.WriteString(w, pos); err != nil {
			return err
		}
	}
	if n.numKids() == 0 {
		if n.name() == "" {
			if _, err := io.WriteString(w, "{}"); err != nil {
				return err
			}
		}
		return nil
	}
	if _, err := io.WriteString(w, "{"); err != nil {
		return err
	}
	if n.numKids() == 1 && n.kid(0).numKids() == 0 {
		if err := prettyWrite(w, "", n.kid(0)); err != nil {
			return err
		}
		if _, err := io.WriteString(w, "}"); err != nil {
			return err
		}
		return nil
	}
	for i := 0; i < n.numKids(); i++ {
		if _, err := io.WriteString(w, "\n"); err != nil {
			return err
		}
		if err := prettyWrite(w, tab+"\t", n.kid(i)); err != nil {
			return err
		}
		if _, err := io.WriteString(w, ","); err != nil {
			return err
		}
	}
	if _, err := io.WriteString(w, "\n"+tab+"}"); err != nil {
		return err
	}
	return nil
}

// DecodeRuneInString is utf8.DecodeRuneInString.
// It's here so parsers can just include peg, and not also need unicode/utf8.
func DecodeRuneInString(s string) (rune, int) {
	return utf8.DecodeRuneInString(s)
}
